MODULE FUSIONUTILS
! subroutines to simulate fusion events between particles
! VERSION BY: SAURABH MOGRE 
! DATE: MAY 2020

CONTAINS
  SUBROUTINE FUSEPARTICLES(PGROUP,PARAMP)
  ! subroutine to implement fusion of particles
    USE PARTICLEUTILS, ONLY: PARTICLEGROUP,PARTICLE,PARTICLEPARAMS,&
                             REMOVEPARTICLE
    USE KEYS, ONLY: USEPFUSE                             
    
    IMPLICIT NONE
    TYPE(PARTICLEGROUP), POINTER :: PGROUP
    TYPE(PARTICLEPARAMS), POINTER :: PARAMP
    TYPE(PARTICLE), POINTER :: PARTP1,PARTP2,PARTP

    INTEGER :: PC1,PC2,NPROC,TOTNPART,DELIND,KEEPIND,NCHECK,REMPART,I
    LOGICAL :: CHECKFUSE

    TOTNPART = SUM(PGROUP%NPART)
    PC1 = 1
    NPROC = 0
    DO WHILE(NPROC.LT.TOTNPART.AND.SUM(PGROUP%NPART).GT.0)
      NPROC = NPROC + 1
      PARTP1=>PGROUP%PLIST(PC1)
      ! PRINT*, 'TESTX, PC, ID, TYPE, CANFUSE?:',PC1,PARTP1%ID,PARTP1%PTYPE,PARTP1%CANFUSE
      IF(.NOT.PARTP1%CANFUSE) THEN
        PC1 = PC1+1
        CYCLE
      END IF

      ! run through other particles
      NCHECK = 0
      PC2 = PC1+1
      REMPART = SUM(PGROUP%NPART)-PC1
      DO WHILE(NCHECK.LT.REMPART.AND.SUM(PGROUP%NPART).GT.0) 
        NCHECK = NCHECK+1
        PARTP2=>PGROUP%PLIST(PC2)
        IF(.NOT.PARTP2%CANFUSE) THEN
          PC2 = PC2+1
          CYCLE
        END IF
        ! PRINT*, 'TESTX, CHECKING FUSION: PC1,PC2,ID1,ID2,TYPE1,TYPE2',&
        ! PC1,PC2,PARTP1%ID,PARTP2%ID,PARTP1%PTYPE,PARTP2%PTYPE
        ! PRINT*, 'TESTX, CHECKING FUSION: SEP',ABS(PARTP1%POS-PARTP2%POS)
        CALL CHECKFUSION(CHECKFUSE,PARTP1,PARTP2)
        IF(CHECKFUSE) THEN
          ! decide which particle to keep
          ! default: particle with larger PTYPE  keeps its identity
          IF(PARTP1%PTYPE.GE.PARTP2%PTYPE) THEN
            DELIND = PC2
            KEEPIND = PC1
          ELSE 
            DELIND = PC1
            KEEPIND = PC2
          END IF
          ! update properties of the fused particle
          PARTP=>PGROUP%PLIST(KEEPIND)
          PARTP%NFUSE = PARTP%NFUSE+1
          IF(PARTP%NFUSE.GE.PARAMP%MAXNFUSE(PARTP%PTYPE)) THEN
            PARTP%CANFUSE = .FALSE.
          END IF
          PARTP%PROTCONV = CONVRATE(PARAMP%PROTCONV(:,:,PARTP%PTYPE),&
                                    PARTP%NFUSE,PARTP%NPROT,PARTP%MAXNFUSE)

          ! remove unused particle                                    
          CALL REMOVEPARTICLE(PGROUP,DELIND)
          IF(DELIND.EQ.PC1) THEN
            PC1 = PC1-1
            EXIT
          ELSE
            NPROC = NPROC+1
            CYCLE
          END IF
        END IF
          PC2 = PC2 + 1
      END DO
      PC1 = PC1+1
    END DO
    
  END SUBROUTINE FUSEPARTICLES

  SUBROUTINE CHECKFUSION(CHECKFUSE,PARTP1,PARTP2)
    !POS1,POS2,PTYPE1,PTYPE2,PRAD1,PRAD2)
  ! subroutine to check whether fusion occurs
    USE PARTICLEUTILS, ONLY: PARTICLE
    USE KEYS, ONLY: USEPFUSE,DELT,PFUSE,KFUSE
    USE MT19937, ONLY: GRND
    TYPE(PARTICLE), POINTER :: PARTP1,PARTP2
    DOUBLE PRECISION :: POS1,POS2
    INTEGER :: PTYPE1,PTYPE2
    DOUBLE PRECISION :: PF,SEP
    LOGICAL, INTENT(OUT) :: CHECKFUSE
    
    CHECKFUSE = .FALSE.

    POS1 = PARTP1%POS
    PTYPE1 = PARTP1%PTYPE
    POS2 = PARTP2%POS
    PTYPE2 = PARTP2%PTYPE
    SEP = ABS(POS1-POS2)

    ! check if particle types match
    IF(PTYPE1.EQ.PTYPE2) RETURN
    
    ! check if particles touch
    IF(SEP.GT.(PARTP1%PRAD+PARTP2%PRAD)) RETURN

    IF(USEPFUSE) THEN
      PF = PFUSE(PTYPE1,PTYPE2)
    ELSE
      PF = 1-EXP(-KFUSE(PTYPE1,PTYPE2)*DELT)
    END IF

    IF(GRND().LE.PF) CHECKFUSE = .TRUE.

  END SUBROUTINE CHECKFUSION

  SUBROUTINE UPDATEFUSESTATE(PGROUP,PARAMP)
  ! updates the fusion state of particles in the group
    USE KEYS, ONLY: BUFLEN,USEPFUSE
    USE PARTICLEUTILS, ONLY: PARTICLEGROUP,PARTICLEPARAMS,PARTICLE 
    IMPLICIT NONE

    TYPE(PARTICLEGROUP), POINTER :: PGROUP
    TYPE(PARTICLEPARAMS), POINTER :: PARAMP
    TYPE(PARTICLE), POINTER :: PARTP1,PARTP2,PHPART,LYSOPART

    DOUBLE PRECISION :: TOUCHSEP,BUFSEP,SEP
    INTEGER :: PC1,PC2,PTYPE1,PTYPE2,I

    TOUCHSEP = SUM(PARAMP%PRAD(1:PARAMP%NTYPE))
    BUFSEP = TOUCHSEP+BUFLEN

    DO PC1 = 1,SUM(PGROUP%NPART)
      PARTP1=>PGROUP%PLIST(PC1)
      PTYPE1 = PARTP1%PTYPE
      DO PC2 = (PC1+1),SUM(PGROUP%NPART)
        PARTP2=>PGROUP%PLIST(PC2)
        PTYPE2 = PARTP2%PTYPE
        IF(PTYPE1.EQ.PTYPE2) THEN
          CYCLE
        ELSE IF(PTYPE1.GT.PTYPE2) THEN
          PHPART=>PARTP1
          LYSOPART=>PARTP2
        ELSE
          PHPART=>PARTP2
          LYSOPART=>PARTP1
        END IF
        PHPART%PROTCONV = CONVRATE(PARAMP%PROTCONV(:,:,PHPART%PTYPE),&
                                        PHPART%NFUSE,PHPART%NPROT,PHPART%MAXNFUSE)
        IF(PHPART%NFUSE.GE.PARAMP%MAXNFUSE(PHPART%PTYPE)) THEN
          PHPART%CANFUSE = .FALSE.
          CYCLE
        END IF
        SEP = ABS(PHPART%POS-LYSOPART%POS)
        IF(SEP.LE.TOUCHSEP) THEN
          IF(.NOT.LYSOPART%INTERACTING) THEN  
            PHPART%NTOUCH = PHPART%NTOUCH+1
            LYSOPART%INTERACTING = .TRUE.
            LYSOPART%CANFUSE = .TRUE.
          ELSE
            LYSOPART%CANFUSE = .FALSE.
          END IF
        ELSEIF(SEP.GT.BUFSEP) THEN
          LYSOPART%CANFUSE = .FALSE.
          LYSOPART%INTERACTING = .FALSE.
        END IF
      END DO
    END DO

  END SUBROUTINE UPDATEFUSESTATE

  FUNCTION CONVRATE(CONVMAT,NFUSE,NPROT,MAXNFUSE)
  ! updates the protein conversion rate based on number of fusion events
    IMPLICIT NONE

    DOUBLE PRECISION :: CONVRATE(NPROT,NPROT)
    DOUBLE PRECISION, INTENT(IN)::CONVMAT(:,:)
    INTEGER, INTENT(IN) :: NFUSE,NPROT,MAXNFUSE

    CONVRATE = CONVMAT*MIN(NFUSE,MAXNFUSE)
    
  END FUNCTION CONVRATE
  

END MODULE FUSIONUTILS